<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>너의 이름은 - 교실 3D 뷰</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { margin:0; padding:0; height:100%; overflow:hidden; background:#111;}
    #ui {
      position: fixed; left: 12px; top: 12px; z-index: 10; color:#fff; font-family: system-ui, Arial, sans-serif;
      display:flex; flex-direction: column; gap:8px; width:min(92vw, 360px);
    }
    #ui .panel {
      background: rgba(0,0,0,0.55); border:1px solid rgba(255,255,255,0.15);
      border-radius: 12px; padding: 12px; backdrop-filter: blur(6px);
    }
    #ui label { font-size:14px; opacity:0.9; display:block; margin-bottom:4px;}
    #ui input, #ui button, #ui select {
      width:100%; padding:10px 12px; border-radius:10px; border:none; outline:none; font-size:14px;
    }
    #ui button { background:#4CAF50; color:#fff; cursor:pointer;}
    #ui button.secondary { background:#2d2d2d; }
    #hint { position: fixed; bottom: 12px; left: 12px; right:12px; color:#ddd; font-size:12px; text-align:center; opacity:0.8;}
    canvas { display:block; }
  </style>
</head>
<body>
  <div id="ui">
    <div class="panel">
      <label>사용할 연도 (저장된 자리배치):</label>
      <input id="year" placeholder="예: 2025" />
      <button id="applyYear">이 연도로 불러오기</button>
    </div>

    <div class="panel">
      <label>기본 격자 (행 × 열) — 저장값 없을 때만 사용</label>
      <div style="display:flex; gap:8px;">
        <input id="rows" type="number" placeholder="행(예:4)" />
        <input id="cols" type="number" placeholder="열(예:6)" />
      </div>
      <button class="secondary" id="regen">교실 다시 만들기</button>
    </div>

    <div class="panel">
      <button id="sensor">📱 센서(회전) 시작</button>
      <button class="secondary" id="centerBoard">🔄 칠판 보기</button>
    </div>
  </div>

  <div id="hint">좌우로 기기를 돌리면 회전 · 화면을 터치한 채 아래로 쓸어내리면 전진 / 위로 쓸어올리면 후진<br/>“나”가 없으면 교실 중앙 시점에서 시작</div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
  <script>
    // ====== 기초 세팅 ======
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x101014);

    const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 2000);
    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight);
    document.body.appendChild(renderer.domElement);

    // 조명
    const hemi = new THREE.HemisphereLight(0xffffff, 0x202028, 0.8);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 0.9);
    dir.position.set(10, 20, 10);
    scene.add(dir);

    // 교실 그룹(카메라 고정, 교실을 움직이는 방식)
    const classroom = new THREE.Group();
    scene.add(classroom);

    // 바닥
    const FLOOR_W = 72, FLOOR_H = 48;
    const floor = new THREE.Mesh(
      new THREE.PlaneGeometry(FLOOR_W, FLOOR_H),
      new THREE.MeshStandardMaterial({ color:0x2a2a32, metalness:0.0, roughness:1.0 })
    );
    floor.rotation.x = -Math.PI/2;
    classroom.add(floor);

    // 칠판(앞쪽 벽, 화면 상단 중앙 느낌으로 Z-쪽)
    const boardW = 24, boardH = 6;
    const board = new THREE.Mesh(
      new THREE.PlaneGeometry(boardW, boardH),
      new THREE.MeshStandardMaterial({ color:0x0f9d58 })
    );
    // 칠판은 바닥 기준 -Z 쪽 벽에 붙여 둔다
    const BOARD_Z = - (FLOOR_H/2) + 2; // 앞쪽
    board.position.set(0, 6, BOARD_Z);
    classroom.add(board);

    // 칠판 위 라벨(“BOARD”) - 간단 텍스처
    classroom.add(makeTextSprite("BOARD", {x:0, y:9, z:BOARD_Z+0.01}));

    // 행/열 및 책상 파라미터
    let rows = 4, cols = 6;
    const desk = { w: 5, h: 3, y: 1.2, gapX: 1.2, gapZ: 2.0 };
    let desks = []; // {mesh, card, data, index, rc:{r,c}}

    // ====== 저장된 데이터 불러오기 ======
    function loadSaved() {
      const year = (document.getElementById('year').value || localStorage.getItem('savedYear') || '').trim();
      if (year) document.getElementById('year').value = year;

      // seatData_YEAR
      const raw = year ? localStorage.getItem(`seatData_${year}`) : null;
      const seatData = raw ? JSON.parse(raw) : [];

      // 저장된 레이아웃 메타(있으면 사용). 없으면 입력창/기본값.
      const metaRows = parseInt(localStorage.getItem(`layout_rows_${year}`) || '') || parseInt(document.getElementById('rows').value || '') || rows;
      const metaCols = parseInt(localStorage.getItem(`layout_cols_${year}`) || '') || parseInt(document.getElementById('cols').value || '') || cols;

      rows = metaRows > 0 ? metaRows : rows;
      cols = metaCols > 0 ? metaCols : cols;

      // 입력창 동기화
      document.getElementById('rows').value = rows;
      document.getElementById('cols').value = cols;

      return { year, seatData };
    }

    // ====== 교실/책상 재구성 ======
    function rebuildClassroom() {
      // 기존 책상 제거
      desks.forEach(d => {
        classroom.remove(d.mesh);
        if (d.card) classroom.remove(d.card);
      });
      desks = [];

      // 현재 seatData
      const { seatData } = loadSaved();
      const total = Math.max(seatData.length || 0, rows*cols);

      // 그리드 시작 오프셋(중앙 정렬)
      const totalW = cols*desk.w + (cols-1)*desk.gapX;
      const totalH = rows*desk.h + (rows-1)*desk.gapZ;
      const startX = -totalW/2 + desk.w/2;
      const startZ = -totalH/2 + desk.h/2;

      for (let i=0; i<rows; i++) {
        for (let j=0; j<cols; j++) {
          const idx = i*cols + j;
          if (idx >= total) break;

          const mesh = new THREE.Mesh(
            new THREE.BoxGeometry(desk.w, 2.2, desk.h),
            new THREE.MeshStandardMaterial({ color:0x7aa5ff })
          );
          mesh.position.set(
            startX + j*(desk.w + desk.gapX),
            1.1,
            startZ + i*(desk.h + desk.gapZ)
          );
          classroom.add(mesh);

          const d = seatData[idx] || null;
          // 카드(사진+이름+메모) — 단순화: 사진이 있으면 위에 세운 이미지, 텍스트는 그 위에
          let card = null;
          if (d && (d.name || d.memo || d.photo)) {
            card = makeDeskCard(d, mesh.position);
            classroom.add(card);
          }

          desks.push({ mesh, card, data:d, index:idx, rc:{r:i, c:j} });
        }
      }
    }

    // ====== 텍스트 라벨(캔버스 텍스처) ======
    function makeTextSprite(text, pos, opts={}) {
      const font = opts.font || '600 36px system-ui, Arial';
      const padding = 16;
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');

      ctx.font = font;
      const tw = Math.ceil(ctx.measureText(text).width);
      canvas.width = tw + padding*2;
      canvas.height = 64 + padding*2;

      // 배경 반투명
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // 글자
      ctx.font = font;
      ctx.fillStyle = '#ffffff';
      ctx.textBaseline = 'middle';
      ctx.fillText(text, padding, canvas.height/2);

      const tex = new THREE.CanvasTexture(canvas);
      tex.minFilter = THREE.LinearFilter;
      const material = new THREE.SpriteMaterial({ map: tex, transparent:true });
      const sprite = new THREE.Sprite(material);
      const scale = opts.scale || 0.06; // 화면 너비 비례 감
      sprite.scale.set(canvas.width*scale, canvas.height*scale, 1);
      sprite.position.set(pos.x, pos.y, pos.z);
      return sprite;
    }

    // ====== 책상 카드(사진 + 텍스트) ======
    function makeDeskCard(d, basePos) {
      const group = new THREE.Group();
      // 사진
      if (d.photo) {
        const tex = new THREE.TextureLoader().load(d.photo);
        const imgW = 3.2, imgH = 2.2;
        const photo = new THREE.Mesh(
          new THREE.PlaneGeometry(imgW, imgH),
          new THREE.MeshStandardMaterial({ map: tex, roughness:1, metalness:0, side:THREE.DoubleSide })
        );
        photo.position.set(basePos.x, basePos.y + 2.0, basePos.z);
        photo.rotation.y = 0;
        group.add(photo);

        // 액자 느낌의 받침(간단 박스)
        const stand = new THREE.Mesh(
          new THREE.BoxGeometry(imgW+0.2, 0.1, 0.4),
          new THREE.MeshStandardMaterial({ color:0x333333 })
        );
        stand.position.set(basePos.x, basePos.y + 1.0, basePos.z - 0.2);
        group.add(stand);
      }
      // 이름/메모 라벨
      const nameText = (d.name || '').trim();
      const memoText = (d.memo || '').trim();
      const label = makeTextSprite(
        (nameText ? nameText : '(빈자리)') + (memoText ? ` · ${memoText}` : ''),
        {x: basePos.x, y: basePos.y + 3.1, z: basePos.z},
        {font:'600 32px system-ui, Arial', scale:0.05}
      );
      group.add(label);

      return group;
    }

    // ====== “나” 자리 기준 카메라 배치 ======
    function placeCameraAtMySeat() {
      const { seatData } = loadSaved();
      const myIndex = (seatData || []).findIndex(d => d && typeof d.name === 'string' && d.name.trim() === '나');

      // 그리드 좌표 계산을 위해 다시 한 번 레이아웃 치수
      const totalW = cols*desk.w + (cols-1)*desk.gapX;
      const totalH = rows*desk.h + (rows-1)*desk.gapZ;
      const startX = -totalW/2 + desk.w/2;
      const startZ = -totalH/2 + desk.h/2;

      let camX = 0, camY = 16, camZ = 26; // 기본 중앙 시점
      if (myIndex >= 0) {
        const r = Math.floor(myIndex / cols);
        const c = myIndex % cols;
        const myX = startX + c*(desk.w + desk.gapX);
        const myZ = startZ + r*(desk.h + desk.gapZ);

        // 카메라: '나' 자리 위 + 뒤에서 20도 내려보기 느낌
        camX = myX;
        camY = 18;      // 고정 높이
        camZ = myZ + 24; // 뒤쪽에서
      }
      camera.position.set(camX, camY, camZ);

      // 칠판(앞쪽, Z가 더 작음)을 바라봄
      camera.lookAt(new THREE.Vector3(0, 5, BOARD_Z));
    }

    // ====== 입력/버튼 핸들러 ======
    document.getElementById('applyYear').addEventListener('click', () => {
      rebuildClassroom();
      placeCameraAtMySeat();
    });
    document.getElementById('regen').addEventListener('click', () => {
      // 사용자가 지정한 행/열 적용
      const r = parseInt(document.getElementById('rows').value || '') || rows;
      const c = parseInt(document.getElementById('cols').value || '') || cols;
      rows = r; cols = c;
      rebuildClassroom();
      placeCameraAtMySeat();
    });
    document.getElementById('centerBoard').addEventListener('click', () => {
      // 칠판을 정면에서 바라보는 구도로 살짝 리셋
      camera.position.set(0, 18, 26);
      camera.lookAt(new THREE.Vector3(0, 5, BOARD_Z));
    });

    // ====== 센서(기기 회전) — 교실을 회전 ======
    let baseAlpha = null;
    function handleOrientation(e) {
  if (typeof e.alpha !== 'number') return;
  if (baseAlpha === null) baseAlpha = e.alpha;
  const yaw = THREE.MathUtils.degToRad(baseAlpha - e.alpha); // 🔄 방향 반전됨
  classroom.rotation.y = yaw;
}

    async function enableSensor() {
      // iOS 권한 요청
      if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
        try {
          const p = await DeviceOrientationEvent.requestPermission();
          if (p !== 'granted') return alert('센서 접근이 거부되었습니다.');
        } catch (err) {
          console.warn(err);
          return alert('센서 요청 중 오류');
        }
      }
      window.addEventListener('deviceorientation', handleOrientation, true);
    }
    document.getElementById('sensor').addEventListener('click', enableSensor);

    // ====== 터치 제스처(전진/후진) — 교실을 Z방향으로 이동 ======
    let touchStartY = null;
    let accumZ = 0; // classroom 전후 이동 누적
    const MOVE_SCALE = 0.04; // 감도

    window.addEventListener('touchstart', (e) => {
      if (e.touches.length === 1) touchStartY = e.touches[0].clientY;
    }, {passive:true});

    window.addEventListener('touchmove', (e) => {
      if (touchStartY === null || e.touches.length !== 1) return;
      const y = e.touches[0].clientY;
      const dy = y - touchStartY;
      // 아래로 내리면 전진(친구들 쪽으로 이동 = 교실을 -Z)
      accumZ = THREE.MathUtils.clamp(accumZ - dy*MOVE_SCALE, -60, 60);
      classroom.position.z = accumZ;
      touchStartY = y;
    }, {passive:true});

    window.addEventListener('touchend', () => { touchStartY = null; });

    // ====== 리사이즈 ======
    addEventListener('resize', () => {
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    // ====== 초기 빌드 ======
    rebuildClassroom();
    placeCameraAtMySeat();

    // ====== 루프 ======
    (function animate(){
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    })();
  </script>
</body>
</html>
