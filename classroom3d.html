<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>교실 3D 보기</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(255,255,255,0.8);
      padding: 10px;
      border-radius: 8px;
      z-index: 10;
    }
  </style>
</head>
<body>
  <div id="ui">
    <label for="year">연도: </label>
    <input type="text" id="year" value="2025" />
    <button onclick="loadData()">이 연도로 불러오기</button>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
  <script>
    let scene, camera, renderer;
    let desks = [];

    init();

    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xf0f0f0);

      camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      const light = new THREE.DirectionalLight(0xffffff, 1);
      light.position.set(10, 20, 10);
      scene.add(light);

      animate();
    }

    function createDeskWithInfo(seat) {
      const group = new THREE.Group();

      // 책상
      const deskGeometry = new THREE.BoxGeometry(8, 2, 8);
      const deskMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
      const desk = new THREE.Mesh(deskGeometry, deskMaterial);
      group.add(desk);

      // 사진
      if (seat.photo) {
        const photoTexture = new THREE.TextureLoader().load(seat.photo);
        const photoGeometry = new THREE.PlaneGeometry(6, 6);
        const photoMaterial = new THREE.MeshBasicMaterial({ map: photoTexture });
        const photoMesh = new THREE.Mesh(photoGeometry, photoMaterial);
        photoMesh.position.set(0, 5, 0);
        group.add(photoMesh);
      }

      // 이름 텍스트
      if (seat.name) {
        const nameCanvas = document.createElement('canvas');
        nameCanvas.width = 256;
        nameCanvas.height = 64;
        const ctx = nameCanvas.getContext('2d');
        ctx.fillStyle = 'black';
        ctx.font = 'bold 28px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(seat.name, 128, 40);

        const nameTexture = new THREE.CanvasTexture(nameCanvas);
        const nameMaterial = new THREE.MeshBasicMaterial({ map: nameTexture, transparent: true });
        const nameGeometry = new THREE.PlaneGeometry(6, 1.5);
        const nameMesh = new THREE.Mesh(nameGeometry, nameMaterial);
        nameMesh.position.set(0, 2.5, -5);
        group.add(nameMesh);
      }

      // 메모
      if (seat.memo) {
        const memoCanvas = document.createElement('canvas');
        memoCanvas.width = 256;
        memoCanvas.height = 64;
        const ctx = memoCanvas.getContext('2d');
        ctx.fillStyle = 'gray';
        ctx.font = '20px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(seat.memo, 128, 40);

        const memoTexture = new THREE.CanvasTexture(memoCanvas);
        const memoMaterial = new THREE.MeshBasicMaterial({ map: memoTexture, transparent: true });
        const memoGeometry = new THREE.PlaneGeometry(6, 1.5);
        const memoMesh = new THREE.Mesh(memoGeometry, memoMaterial);
        memoMesh.position.set(0, 1, -5);
        group.add(memoMesh);
      }

      return group;
    }

    function loadData() {
      const year = document.getElementById("year").value;
      const layoutRows = parseInt(localStorage.getItem("layout_rows_" + year));
      const layoutCols = parseInt(localStorage.getItem("layout_cols_" + year));
      const seatData = JSON.parse(localStorage.getItem("seatData_" + year));

      if (!layoutRows || !layoutCols || !seatData) {
        alert("데이터를 찾을 수 없습니다.");
        return;
      }

      desks.forEach(d => scene.remove(d));
      desks = [];

      for (let r = 0; r < layoutRows; r++) {
        for (let c = 0; c < layoutCols; c++) {
          const index = r * layoutCols + c;
          const seat = seatData[index] || {};
          const desk = createDeskWithInfo(seat);
          desk.position.set(c * 12, 0, r * 12);
          desks.push(desk);
          scene.add(desk);
        }
      }

      const myIndex = seatData.findIndex(s => s.name === "나");
      if (myIndex >= 0) {
        const row = Math.floor(myIndex / layoutCols);
        const col = myIndex % layoutCols;
        const myX = col * 12;
        const myZ = row * 12;
        camera.position.set(myX, 20, myZ + 20);
        camera.lookAt(myX, 0, myZ - 20);
      }
    }

    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
