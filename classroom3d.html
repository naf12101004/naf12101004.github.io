<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>교실 3D 보기</title>
  <style>
    body { margin: 0; overflow: hidden; font-family: sans-serif; }
    canvas { display: block; }
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(255,255,255,0.9);
      padding: 10px;
      border-radius: 8px;
      box-shadow: 0 0 10px rgba(0,0,0,0.2);
      z-index: 10;
    }
    #ui input, #ui button {
      font-size: 16px;
      padding: 4px 8px;
      margin: 4px 0;
    }
  </style>
</head>
<body>
  <div id="ui">
    <label for="year">연도: </label>
    <input type="text" id="year" value="2025" />
    <button onclick="loadData()">이 연도로 불러오기</button>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
  <script>
    let scene, camera, renderer;
    let desks = [];

    init();

    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xf0f0f0);

      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      const light = new THREE.DirectionalLight(0xffffff, 1);
      light.position.set(10, 20, 10);
      scene.add(light);

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      animate();
    }

    function createDeskWithInfo(seat) {
      const group = new THREE.Group();

      const deskGeometry = new THREE.BoxGeometry(8, 2, 8);
      const deskMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
      const desk = new THREE.Mesh(deskGeometry, deskMaterial);
      group.add(desk);

      if (seat.photo) {
        const photoTexture = new THREE.TextureLoader().load(seat.photo);
        const photoGeometry = new THREE.PlaneGeometry(6, 6);
        const photoMaterial = new THREE.MeshBasicMaterial({ map: photoTexture });
        const photoMesh = new THREE.Mesh(photoGeometry, photoMaterial);
        photoMesh.position.set(0, 5, 0);
        photoMesh.userData = { fullImage: seat.photo };
        photoMesh.cursor = 'pointer';
        photoMesh.onClick = () => {
          window.open(seat.photo, '_blank');
        };
        group.add(photoMesh);

        // 카드 테두리 추가
        const borderGeo = new THREE.PlaneGeometry(6.2, 6.2);
        const borderMat = new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.DoubleSide });
        const border = new THREE.Mesh(borderGeo, borderMat);
        border.position.set(0, 5, -0.01);
        group.add(border);
      }

      if (seat.name) {
        const nameCanvas = document.createElement('canvas');
        nameCanvas.width = 256;
        nameCanvas.height = 64;
        const ctx = nameCanvas.getContext('2d');
        ctx.fillStyle = 'black';
        ctx.font = '20px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(seat.name, 128, 40);

        const nameTexture = new THREE.CanvasTexture(nameCanvas);
        const nameMaterial = new THREE.MeshBasicMaterial({ map: nameTexture, transparent: true });
        const nameGeometry = new THREE.PlaneGeometry(6, 1.5);
        const nameMesh = new THREE.Mesh(nameGeometry, nameMaterial);
        nameMesh.position.set(0, 3.2, -5);
        group.add(nameMesh);
      }

      if (seat.memo) {
        const memoCanvas = document.createElement('canvas');
        memoCanvas.width = 256;
        memoCanvas.height = 64;
        const ctx = memoCanvas.getContext('2d');
        ctx.fillStyle = 'gray';
        ctx.font = '16px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(seat.memo, 128, 40);

        const memoTexture = new THREE.CanvasTexture(memoCanvas);
        const memoMaterial = new THREE.MeshBasicMaterial({ map: memoTexture, transparent: true });
        const memoGeometry = new THREE.PlaneGeometry(6, 1.2);
        const memoMesh = new THREE.Mesh(memoGeometry, memoMaterial);
        memoMesh.position.set(0, 1.6, -5);
        group.add(memoMesh);
      }

      return group;
    }

    function loadData() {
      const year = document.getElementById("year").value;
      const layoutRows = parseInt(localStorage.getItem("layout_rows_" + year));
      const layoutCols = parseInt(localStorage.getItem("layout_cols_" + year));
      const seatData = JSON.parse(localStorage.getItem("seatData_" + year));

      if (!layoutRows || !layoutCols || !seatData) {
        alert("데이터를 찾을 수 없습니다.");
        return;
      }

      desks.forEach(d => scene.remove(d));
      desks = [];

      for (let r = 0; r < layoutRows; r++) {
        for (let c = 0; c < layoutCols; c++) {
          const index = r * layoutCols + c;
          const seat = seatData[index] || {};
          const desk = createDeskWithInfo(seat);
          desk.position.set(c * 12, 0, r * 12);
          desks.push(desk);
          scene.add(desk);
        }
      }

      const myIndex = seatData.findIndex(s => s.name === "나");
      if (myIndex >= 0) {
        const row = Math.floor(myIndex / layoutCols);
        const col = myIndex % layoutCols;
        const myX = col * 12;
        const myZ = row * 12;
        camera.position.set(myX, 20, myZ + 20);
        camera.lookAt(myX, 0, myZ - 20);
      }
    }

    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }

    // 사진 클릭 이벤트 연결용 Raycaster
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    window.addEventListener('click', (event) => {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(scene.children, true);
      for (let i = 0; i < intersects.length; i++) {
        const obj = intersects[i].object;
        if (obj.onClick) {
          obj.onClick();
          break;
        }
      }
    });
  </script>
</body>
</html>
